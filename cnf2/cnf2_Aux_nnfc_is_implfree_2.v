(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require list.List.

Axiom i : Type.
Parameter i_WhyType : WhyType i.
Existing Instance i_WhyType.

Axiom b : Type.
Parameter b_WhyType : WhyType b.
Existing Instance b_WhyType.

Parameter top: b.

Parameter bot: b.

Parameter infix_slasbs: b -> b -> b.

Parameter infix_bsassl: b -> b -> b.

Parameter neg: b -> b.

(* Why3 assumption *)
Definition xor (x:b) (y:b) : b :=
  infix_slasbs (infix_bsassl x y) (neg (infix_slasbs x y)).

Axiom Assoc :
  forall (x:b) (y:b) (z:b), ((xor (xor x y) z) = (xor x (xor y z))).

Axiom Unit_def_l : forall (x:b), ((xor bot x) = x).

Axiom Unit_def_r : forall (x:b), ((xor x bot) = x).

Axiom Inv_def_l : forall (x:b), ((xor x x) = bot).

Axiom Inv_def_r : forall (x:b), ((xor x x) = bot).

Axiom Comm : forall (x:b) (y:b), ((xor x y) = (xor y x)).

Axiom Assoc1 :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs (infix_slasbs x y) z) = (infix_slasbs x (infix_slasbs y z))).

Axiom Mul_distr_l :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (xor y z)) = (xor (infix_slasbs x y) (infix_slasbs x z))).

Axiom Mul_distr_r :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs (xor y z) x) = (xor (infix_slasbs y x) (infix_slasbs z x))).

Axiom Comm1 : forall (x:b) (y:b), ((infix_slasbs x y) = (infix_slasbs y x)).

Axiom Unit_def_l1 : forall (x:b), ((infix_slasbs top x) = x).

Axiom Unit_def_r1 : forall (x:b), ((infix_slasbs x top) = x).

Axiom NonTrivialRing : ~ (bot = top).

Axiom Idempotence : forall (x:b), ((infix_slasbs x x) = x).

Axiom br_equivalent_law_1 : forall (a:b), ((xor a a) = bot).

(* Why3 assumption *)
Definition infix_lseq (x:b) (y:b) : Prop := ((infix_bsassl x y) = y).

Axiom Refl : forall (x:b), infix_lseq x x.

Axiom Trans :
  forall (x:b) (y:b) (z:b), infix_lseq x y -> infix_lseq y z ->
  infix_lseq x z.

Axiom Antisymm :
  forall (x:b) (y:b), infix_lseq x y -> infix_lseq y x -> (x = y).

Axiom glb_infimum :
  forall (x:b) (y:b),
  infix_lseq (infix_slasbs x y) x /\
  infix_lseq (infix_slasbs x y) y /\
  (forall (w:b), infix_lseq w x /\ infix_lseq w y ->
   infix_lseq w (infix_slasbs x y)).

Axiom lub_supremum :
  forall (x:b) (y:b),
  infix_lseq x (infix_bsassl x y) /\
  infix_lseq y (infix_bsassl x y) /\
  (forall (w:b), infix_lseq x w /\ infix_lseq y w ->
   infix_lseq (infix_bsassl x y) w).

Axiom comm_meet :
  forall (x:b) (y:b), ((infix_bsassl x y) = (infix_bsassl y x)).

Axiom comm_join :
  forall (x:b) (y:b), ((infix_slasbs x y) = (infix_slasbs y x)).

Axiom assoc_meet :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (infix_slasbs y z)) = (infix_slasbs (infix_slasbs x y) z)).

Axiom assoc_join :
  forall (x:b) (y:b) (z:b),
  ((infix_bsassl x (infix_bsassl y z)) = (infix_bsassl (infix_bsassl x y) z)).

Axiom absorp_meet :
  forall (x:b) (y:b), ((infix_slasbs x (infix_bsassl x y)) = x).

Axiom absorp_join :
  forall (x:b) (y:b), ((infix_bsassl x (infix_slasbs x y)) = x).

Axiom idem_meet : forall (x:b), ((infix_slasbs x x) = x).

Axiom idem_join : forall (x:b), ((infix_bsassl x x) = x).

Axiom order :
  forall (x:b) (y:b), ((infix_bsassl x y) = x) -> ((infix_slasbs x y) = y).

Axiom dl_dist_one :
  forall (a:b) (b1:b) (c:b),
  ((infix_bsassl a (infix_slasbs b1 c)) =
   (infix_slasbs (infix_bsassl a b1) (infix_bsassl a c))).

Axiom dl_dist_two :
  forall (a:b) (b1:b) (c:b),
  ((infix_slasbs a (infix_bsassl b1 c)) =
   (infix_bsassl (infix_slasbs a b1) (infix_slasbs a c))).

Axiom dist_meet :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (infix_bsassl y z)) =
   (infix_bsassl (infix_slasbs x y) (infix_slasbs x z))).

Axiom dist_join :
  forall (x:b) (y:b) (z:b),
  ((infix_bsassl x (infix_slasbs y z)) =
   (infix_slasbs (infix_bsassl x y) (infix_bsassl x z))).

Axiom Refl1 : forall (x:b), infix_lseq x x.

Axiom Trans1 :
  forall (x:b) (y:b) (z:b), infix_lseq x y -> infix_lseq y z ->
  infix_lseq x z.

Axiom Antisymm1 :
  forall (x:b) (y:b), infix_lseq x y -> infix_lseq y x -> (x = y).

Axiom glb_infimum1 :
  forall (x:b) (y:b),
  infix_lseq (infix_slasbs x y) x /\
  infix_lseq (infix_slasbs x y) y /\
  (forall (w:b), infix_lseq w x /\ infix_lseq w y ->
   infix_lseq w (infix_slasbs x y)).

Axiom lub_supremum1 :
  forall (x:b) (y:b),
  infix_lseq x (infix_bsassl x y) /\
  infix_lseq y (infix_bsassl x y) /\
  (forall (w:b), infix_lseq x w /\ infix_lseq y w ->
   infix_lseq (infix_bsassl x y) w).

Axiom comm_meet1 :
  forall (x:b) (y:b), ((infix_bsassl x y) = (infix_bsassl y x)).

Axiom comm_join1 :
  forall (x:b) (y:b), ((infix_slasbs x y) = (infix_slasbs y x)).

Axiom assoc_meet1 :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (infix_slasbs y z)) = (infix_slasbs (infix_slasbs x y) z)).

Axiom assoc_join1 :
  forall (x:b) (y:b) (z:b),
  ((infix_bsassl x (infix_bsassl y z)) = (infix_bsassl (infix_bsassl x y) z)).

Axiom absorp_meet1 :
  forall (x:b) (y:b), ((infix_slasbs x (infix_bsassl x y)) = x).

Axiom absorp_join1 :
  forall (x:b) (y:b), ((infix_bsassl x (infix_slasbs x y)) = x).

Axiom idem_meet1 : forall (x:b), ((infix_slasbs x x) = x).

Axiom idem_join1 : forall (x:b), ((infix_bsassl x x) = x).

Axiom order1 :
  forall (x:b) (y:b), ((infix_bsassl x y) = x) -> ((infix_slasbs x y) = y).

Axiom lowerBoundZero : forall (x:b), infix_lseq bot x.

Axiom upperBoundOne : forall (x:b), infix_lseq x top.

Axiom ident_meet : forall (x:b), ((infix_slasbs x top) = x).

Axiom ident_join : forall (x:b), ((infix_bsassl x bot) = x).

Axiom bound_glb : forall (x:b), ((infix_slasbs x bot) = bot).

Axiom bound_lub : forall (x:b), ((infix_bsassl x top) = top).

Axiom cl_compl_top : forall (a:b), exists x:b, ((infix_bsassl a x) = top).

Axiom cl_compl_bot : forall (a:b), exists x:b, ((infix_slasbs a x) = bot).

Axiom lattice_ring :
  forall (x:b) (y:b),
  (infix_lseq x y <-> ((infix_slasbs x y) = x)) /\
  (((infix_slasbs x y) = x) <-> ((infix_bsassl x y) = y)).

Axiom comm_and :
  forall (x:b) (y:b), ((infix_slasbs x y) = (infix_slasbs y x)).

Axiom comm_or :
  forall (x:b) (y:b), ((infix_bsassl x y) = (infix_bsassl y x)).

Axiom dist_and :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (infix_bsassl y z)) =
   (infix_bsassl (infix_slasbs x y) (infix_slasbs x z))).

Axiom dist_or :
  forall (x:b) (y:b) (z:b),
  ((infix_bsassl x (infix_slasbs y z)) =
   (infix_slasbs (infix_bsassl x y) (infix_bsassl x z))).

Axiom ident_and : forall (x:b), ((infix_slasbs x top) = x).

Axiom ident_or : forall (x:b), ((infix_bsassl x bot) = x).

Axiom uniq_compl :
  forall (x:b) (y:b) (z:b), ((neg x) = y) /\ ((neg x) = z) -> (y = z).

Axiom compl_and : forall (x:b), ((infix_slasbs x (neg x)) = bot).

Axiom compl_or : forall (x:b), ((infix_bsassl x (neg x)) = top).

Axiom idem_and : forall (x:b), ((infix_slasbs x x) = x).

Axiom idem_or : forall (x:b), ((infix_bsassl x x) = x).

Axiom boundbot : forall (x:b), infix_lseq bot x.

Axiom boundtop : forall (x:b), infix_lseq x top.

Axiom bound_and : forall (x:b), ((infix_slasbs x bot) = bot).

Axiom bound_or : forall (x:b), ((infix_bsassl x top) = top).

Axiom absorp_and :
  forall (x:b) (y:b), ((infix_slasbs x (infix_bsassl x y)) = x).

Axiom absorp_or :
  forall (x:b) (y:b), ((infix_bsassl x (infix_slasbs x y)) = x).

Axiom assoc_and :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (infix_slasbs y z)) = (infix_slasbs (infix_slasbs x y) z)).

Axiom assoc_or :
  forall (x:b) (y:b) (z:b),
  ((infix_bsassl x (infix_bsassl y z)) = (infix_bsassl (infix_bsassl x y) z)).

Axiom demorgan_and :
  forall (x:b) (y:b),
  ((neg (infix_slasbs x y)) = (infix_bsassl (neg x) (neg y))).

Axiom demorgan_or :
  forall (x:b) (y:b),
  ((neg (infix_bsassl x y)) = (infix_slasbs (neg x) (neg y))).

Axiom negtop : ((neg top) = bot).

Axiom negbot : ((neg bot) = top).

Axiom double_neg : forall (x:b), ((neg (neg x)) = x).

Axiom dist_ord :
  forall (x:b) (y:b) (z:b), infix_lseq x z ->
  ((infix_bsassl x (infix_slasbs y z)) = (infix_slasbs (infix_bsassl x y) z)).

(* Why3 assumption *)
Definition infix_mngtas (x:b) (y:b) : b := infix_bsassl (neg x) y.

(* Why3 assumption *)
Definition usequiv (x:b) (y:b) : b :=
  infix_slasbs (infix_mngtas x y) (infix_mngtas y x).

Axiom disj_and :
  forall (x:b) (y:b),
  (x = (infix_slasbs x y)) /\ ((infix_slasbs x y) = top) -> (x = top).

Axiom disj_or : forall (x:b) (y:b), (x = top) -> ((infix_bsassl x y) = top).

Axiom modus_ponens :
  forall (x:b) (y:b), ((infix_slasbs x (infix_mngtas x y)) = top) ->
  (y = top).

Axiom modus_tollens :
  forall (x:b) (y:b), ((infix_slasbs (infix_mngtas x y) (neg y)) = top) ->
  ((neg x) = top).

Axiom implic :
  forall (x:b) (y:b), ((infix_mngtas x y) = (infix_bsassl (neg x) y)).

Axiom absur :
  forall (x:b) (y:b),
  ((infix_slasbs (infix_mngtas x y) (infix_mngtas x (neg y))) = (neg x)).

Axiom disj_syl :
  forall (x:b) (y:b), ((infix_slasbs (infix_bsassl x y) (neg x)) = top) ->
  (y = top).

Axiom impl_chain :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs (infix_mngtas x y) (infix_mngtas y z)) = top) ->
  ((infix_mngtas x z) = top).

Axiom impl_comb :
  forall (x:b) (y:b) (z:b) (w:b),
  ((infix_slasbs (infix_mngtas x y) (infix_mngtas z w)) = top) ->
  ((infix_mngtas (infix_slasbs x z) (infix_slasbs y w)) = top).

Axiom currying :
  forall (x:b) (y:b) (z:b),
  ((infix_mngtas (infix_slasbs x y) z) = (infix_mngtas x (infix_mngtas y z))).

Axiom contrapos :
  forall (x:b) (y:b), ((infix_mngtas x y) = (infix_mngtas (neg y) (neg x))).

Axiom binary : forall (x:b), (x = top) \/ (x = bot).

Axiom ifnottop_thenbot : forall (t:b), ~ (t = top) -> (t = bot).

Axiom ifnotbot_thentop : forall (t:b), ~ (t = bot) -> (t = top).

(* Why3 assumption *)
Inductive formula :=
  | Prop1 : b -> formula
  | Var : i -> formula
  | Neg : formula -> formula
  | And : formula -> formula -> formula
  | Or : formula -> formula -> formula
  | Impl : formula -> formula -> formula.
Axiom formula_WhyType : WhyType formula.
Existing Instance formula_WhyType.

(* Why3 assumption *)
Fixpoint eval (e:formula) (f:i -> b) {struct e}: b :=
  match e with
  | Prop1 b1 => b1
  | Var i1 => f i1
  | Neg e1 => neg (eval e1 f)
  | And e1 e2 => infix_slasbs (eval e1 f) (eval e2 f)
  | Or e1 e2 => infix_bsassl (eval e1 f) (eval e2 f)
  | Impl e1 e2 => infix_mngtas (eval e1 f) (eval e2 f)
  end.

(* Why3 assumption *)
Inductive atom :=
  | B : b -> atom
  | I : i -> atom
  | Ni : i -> atom.
Axiom atom_WhyType : WhyType atom.
Existing Instance atom_WhyType.

(* Why3 assumption *)
Definition cnf_clause := Init.Datatypes.list atom.

(* Why3 assumption *)
Definition cnf := Init.Datatypes.list (Init.Datatypes.list atom).

(* Why3 assumption *)
Fixpoint eval_cnf_clause (e:Init.Datatypes.list atom)
  (f:i -> b) {struct e}: b :=
  match e with
  | Init.Datatypes.nil => bot
  | Init.Datatypes.cons (B b1) tl => infix_bsassl b1 (eval_cnf_clause tl f)
  | Init.Datatypes.cons (I i1) tl =>
      infix_bsassl (f i1) (eval_cnf_clause tl f)
  | Init.Datatypes.cons (Ni i1) tl =>
      infix_bsassl (neg (f i1)) (eval_cnf_clause tl f)
  end.

(* Why3 assumption *)
Fixpoint eval_cnf (e:Init.Datatypes.list (Init.Datatypes.list atom))
  (f:i -> b) {struct e}: b :=
  match e with
  | Init.Datatypes.nil => top
  | Init.Datatypes.cons hd tl =>
      infix_slasbs (eval_cnf_clause hd f) (eval_cnf tl f)
  end.

(* Why3 assumption *)
Fixpoint size (phi:formula) {struct phi}: Numbers.BinNums.Z :=
  match phi with
  | Neg phi1 => (1%Z + (size phi1))%Z
  | (And phi1 phi2)|((Or phi1 phi2)|(Impl phi1 phi2)) =>
      ((1%Z + (size phi1))%Z + (size phi2))%Z
  | _ => 1%Z
  end.

Axiom size'spec : forall (phi:formula), (0%Z <= (size phi))%Z.

(* Why3 assumption *)
Fixpoint size_cnf_clause
  (phi:Init.Datatypes.list atom) {struct phi}: Numbers.BinNums.Z :=
  match phi with
  | Init.Datatypes.nil => 0%Z
  | Init.Datatypes.cons hd tl => (1%Z + (size_cnf_clause tl))%Z
  end.

Axiom size_cnf_clause'spec :
  forall (phi:Init.Datatypes.list atom), (0%Z <= (size_cnf_clause phi))%Z.

(* Why3 assumption *)
Fixpoint size_cnf
  (phi:Init.Datatypes.list (Init.Datatypes.list atom)) {struct phi}: Numbers.BinNums.Z :=
  match phi with
  | Init.Datatypes.nil => 0%Z
  | Init.Datatypes.cons hd tl => (1%Z + (size_cnf tl))%Z
  end.

Axiom size_cnf'spec :
  forall (phi:Init.Datatypes.list (Init.Datatypes.list atom)),
  (0%Z <= (size_cnf phi))%Z.

(* Why3 assumption *)
Fixpoint is_impl_free (phi:formula) {struct phi}: Prop :=
  match phi with
  | Prop1 t => True
  | Var i1 => True
  | Neg phi1 => is_impl_free phi1
  | (Or phi1 phi2)|(And phi1 phi2) => is_impl_free phi1 /\ is_impl_free phi2
  | Impl phi1 phi2 => False
  end.

(* Why3 assumption *)
Fixpoint is_nnfc (phi:formula) {struct phi}: Prop :=
  match phi with
  | Prop1 t => True
  | Var i1 => True
  | Neg (Prop1 t) => True
  | Neg (Var i1) => True
  | Neg _ => False
  | (Or phi1 phi2)|(And phi1 phi2) => is_nnfc phi1 /\ is_nnfc phi2
  | Impl phi1 phi2 => False
  end.

(* Why3 goal *)
Theorem nnfc_is_implfree :
  forall (phi:formula), is_nnfc phi -> is_impl_free phi.
Proof.
intros phi h1.

Qed.

