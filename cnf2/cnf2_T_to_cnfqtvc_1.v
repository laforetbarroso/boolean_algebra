(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require list.List.
Require list.Length.
Require list.Mem.
Require list.Append.

Axiom i : Type.
Parameter i_WhyType : WhyType i.
Existing Instance i_WhyType.

Axiom b : Type.
Parameter b_WhyType : WhyType b.
Existing Instance b_WhyType.

Parameter top: b.

Parameter bot: b.

Parameter infix_slasbs: b -> b -> b.

Parameter infix_bsassl: b -> b -> b.

Parameter neg: b -> b.

(* Why3 assumption *)
Definition xor (x:b) (y:b) : b :=
  infix_slasbs (infix_bsassl x y) (neg (infix_slasbs x y)).

Axiom Assoc :
  forall (x:b) (y:b) (z:b), ((xor (xor x y) z) = (xor x (xor y z))).

Axiom Unit_def_l : forall (x:b), ((xor bot x) = x).

Axiom Unit_def_r : forall (x:b), ((xor x bot) = x).

Axiom Inv_def_l : forall (x:b), ((xor x x) = bot).

Axiom Inv_def_r : forall (x:b), ((xor x x) = bot).

Axiom Comm : forall (x:b) (y:b), ((xor x y) = (xor y x)).

Axiom Assoc1 :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs (infix_slasbs x y) z) = (infix_slasbs x (infix_slasbs y z))).

Axiom Mul_distr_l :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (xor y z)) = (xor (infix_slasbs x y) (infix_slasbs x z))).

Axiom Mul_distr_r :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs (xor y z) x) = (xor (infix_slasbs y x) (infix_slasbs z x))).

Axiom Comm1 : forall (x:b) (y:b), ((infix_slasbs x y) = (infix_slasbs y x)).

Axiom Unit_def_l1 : forall (x:b), ((infix_slasbs top x) = x).

Axiom Unit_def_r1 : forall (x:b), ((infix_slasbs x top) = x).

Axiom NonTrivialRing : ~ (bot = top).

Axiom Idempotence : forall (x:b), ((infix_slasbs x x) = x).

Axiom br_equivalent_law_1 : forall (a:b), ((xor a a) = bot).

(* Why3 assumption *)
Definition infix_lseq (x:b) (y:b) : Prop := ((infix_bsassl x y) = y).

Axiom Refl : forall (x:b), infix_lseq x x.

Axiom Trans :
  forall (x:b) (y:b) (z:b), infix_lseq x y -> infix_lseq y z ->
  infix_lseq x z.

Axiom Antisymm :
  forall (x:b) (y:b), infix_lseq x y -> infix_lseq y x -> (x = y).

Axiom glb_infimum :
  forall (x:b) (y:b),
  infix_lseq (infix_slasbs x y) x /\
  infix_lseq (infix_slasbs x y) y /\
  (forall (w:b), infix_lseq w x /\ infix_lseq w y ->
   infix_lseq w (infix_slasbs x y)).

Axiom lub_supremum :
  forall (x:b) (y:b),
  infix_lseq x (infix_bsassl x y) /\
  infix_lseq y (infix_bsassl x y) /\
  (forall (w:b), infix_lseq x w /\ infix_lseq y w ->
   infix_lseq (infix_bsassl x y) w).

Axiom comm_meet :
  forall (x:b) (y:b), ((infix_bsassl x y) = (infix_bsassl y x)).

Axiom comm_join :
  forall (x:b) (y:b), ((infix_slasbs x y) = (infix_slasbs y x)).

Axiom assoc_meet :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (infix_slasbs y z)) = (infix_slasbs (infix_slasbs x y) z)).

Axiom assoc_join :
  forall (x:b) (y:b) (z:b),
  ((infix_bsassl x (infix_bsassl y z)) = (infix_bsassl (infix_bsassl x y) z)).

Axiom absorp_meet :
  forall (x:b) (y:b), ((infix_slasbs x (infix_bsassl x y)) = x).

Axiom absorp_join :
  forall (x:b) (y:b), ((infix_bsassl x (infix_slasbs x y)) = x).

Axiom idem_meet : forall (x:b), ((infix_slasbs x x) = x).

Axiom idem_join : forall (x:b), ((infix_bsassl x x) = x).

Axiom order :
  forall (x:b) (y:b), ((infix_bsassl x y) = x) -> ((infix_slasbs x y) = y).

Axiom dl_dist_one :
  forall (a:b) (b1:b) (c:b),
  ((infix_bsassl a (infix_slasbs b1 c)) =
   (infix_slasbs (infix_bsassl a b1) (infix_bsassl a c))).

Axiom dl_dist_two :
  forall (a:b) (b1:b) (c:b),
  ((infix_slasbs a (infix_bsassl b1 c)) =
   (infix_bsassl (infix_slasbs a b1) (infix_slasbs a c))).

Axiom dist_meet :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (infix_bsassl y z)) =
   (infix_bsassl (infix_slasbs x y) (infix_slasbs x z))).

Axiom dist_join :
  forall (x:b) (y:b) (z:b),
  ((infix_bsassl x (infix_slasbs y z)) =
   (infix_slasbs (infix_bsassl x y) (infix_bsassl x z))).

Axiom Refl1 : forall (x:b), infix_lseq x x.

Axiom Trans1 :
  forall (x:b) (y:b) (z:b), infix_lseq x y -> infix_lseq y z ->
  infix_lseq x z.

Axiom Antisymm1 :
  forall (x:b) (y:b), infix_lseq x y -> infix_lseq y x -> (x = y).

Axiom glb_infimum1 :
  forall (x:b) (y:b),
  infix_lseq (infix_slasbs x y) x /\
  infix_lseq (infix_slasbs x y) y /\
  (forall (w:b), infix_lseq w x /\ infix_lseq w y ->
   infix_lseq w (infix_slasbs x y)).

Axiom lub_supremum1 :
  forall (x:b) (y:b),
  infix_lseq x (infix_bsassl x y) /\
  infix_lseq y (infix_bsassl x y) /\
  (forall (w:b), infix_lseq x w /\ infix_lseq y w ->
   infix_lseq (infix_bsassl x y) w).

Axiom comm_meet1 :
  forall (x:b) (y:b), ((infix_bsassl x y) = (infix_bsassl y x)).

Axiom comm_join1 :
  forall (x:b) (y:b), ((infix_slasbs x y) = (infix_slasbs y x)).

Axiom assoc_meet1 :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (infix_slasbs y z)) = (infix_slasbs (infix_slasbs x y) z)).

Axiom assoc_join1 :
  forall (x:b) (y:b) (z:b),
  ((infix_bsassl x (infix_bsassl y z)) = (infix_bsassl (infix_bsassl x y) z)).

Axiom absorp_meet1 :
  forall (x:b) (y:b), ((infix_slasbs x (infix_bsassl x y)) = x).

Axiom absorp_join1 :
  forall (x:b) (y:b), ((infix_bsassl x (infix_slasbs x y)) = x).

Axiom idem_meet1 : forall (x:b), ((infix_slasbs x x) = x).

Axiom idem_join1 : forall (x:b), ((infix_bsassl x x) = x).

Axiom order1 :
  forall (x:b) (y:b), ((infix_bsassl x y) = x) -> ((infix_slasbs x y) = y).

Axiom lowerBoundZero : forall (x:b), infix_lseq bot x.

Axiom upperBoundOne : forall (x:b), infix_lseq x top.

Axiom ident_meet : forall (x:b), ((infix_slasbs x top) = x).

Axiom ident_join : forall (x:b), ((infix_bsassl x bot) = x).

Axiom bound_glb : forall (x:b), ((infix_slasbs x bot) = bot).

Axiom bound_lub : forall (x:b), ((infix_bsassl x top) = top).

Axiom cl_compl_top : forall (a:b), exists x:b, ((infix_bsassl a x) = top).

Axiom cl_compl_bot : forall (a:b), exists x:b, ((infix_slasbs a x) = bot).

Axiom lattice_ring :
  forall (x:b) (y:b),
  (infix_lseq x y <-> ((infix_slasbs x y) = x)) /\
  (((infix_slasbs x y) = x) <-> ((infix_bsassl x y) = y)).

Axiom comm_and :
  forall (x:b) (y:b), ((infix_slasbs x y) = (infix_slasbs y x)).

Axiom comm_or :
  forall (x:b) (y:b), ((infix_bsassl x y) = (infix_bsassl y x)).

Axiom dist_and :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (infix_bsassl y z)) =
   (infix_bsassl (infix_slasbs x y) (infix_slasbs x z))).

Axiom dist_or :
  forall (x:b) (y:b) (z:b),
  ((infix_bsassl x (infix_slasbs y z)) =
   (infix_slasbs (infix_bsassl x y) (infix_bsassl x z))).

Axiom ident_and : forall (x:b), ((infix_slasbs x top) = x).

Axiom ident_or : forall (x:b), ((infix_bsassl x bot) = x).

Axiom uniq_compl :
  forall (x:b) (y:b) (z:b), ((neg x) = y) /\ ((neg x) = z) -> (y = z).

Axiom compl_and : forall (x:b), ((infix_slasbs x (neg x)) = bot).

Axiom compl_or : forall (x:b), ((infix_bsassl x (neg x)) = top).

Axiom idem_and : forall (x:b), ((infix_slasbs x x) = x).

Axiom idem_or : forall (x:b), ((infix_bsassl x x) = x).

Axiom boundbot : forall (x:b), infix_lseq bot x.

Axiom boundtop : forall (x:b), infix_lseq x top.

Axiom bound_and : forall (x:b), ((infix_slasbs x bot) = bot).

Axiom bound_or : forall (x:b), ((infix_bsassl x top) = top).

Axiom absorp_and :
  forall (x:b) (y:b), ((infix_slasbs x (infix_bsassl x y)) = x).

Axiom absorp_or :
  forall (x:b) (y:b), ((infix_bsassl x (infix_slasbs x y)) = x).

Axiom assoc_and :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs x (infix_slasbs y z)) = (infix_slasbs (infix_slasbs x y) z)).

Axiom assoc_or :
  forall (x:b) (y:b) (z:b),
  ((infix_bsassl x (infix_bsassl y z)) = (infix_bsassl (infix_bsassl x y) z)).

Axiom demorgan_and :
  forall (x:b) (y:b),
  ((neg (infix_slasbs x y)) = (infix_bsassl (neg x) (neg y))).

Axiom demorgan_or :
  forall (x:b) (y:b),
  ((neg (infix_bsassl x y)) = (infix_slasbs (neg x) (neg y))).

Axiom negtop : ((neg top) = bot).

Axiom negbot : ((neg bot) = top).

Axiom double_neg : forall (x:b), ((neg (neg x)) = x).

Axiom dist_ord :
  forall (x:b) (y:b) (z:b), infix_lseq x z ->
  ((infix_bsassl x (infix_slasbs y z)) = (infix_slasbs (infix_bsassl x y) z)).

(* Why3 assumption *)
Definition infix_mngtas (x:b) (y:b) : b := infix_bsassl (neg x) y.

(* Why3 assumption *)
Definition usequiv (x:b) (y:b) : b :=
  infix_slasbs (infix_mngtas x y) (infix_mngtas y x).

Axiom disj_and :
  forall (x:b) (y:b),
  (x = (infix_slasbs x y)) /\ ((infix_slasbs x y) = top) -> (x = top).

Axiom disj_or : forall (x:b) (y:b), (x = top) -> ((infix_bsassl x y) = top).

Axiom modus_ponens :
  forall (x:b) (y:b), ((infix_slasbs x (infix_mngtas x y)) = top) ->
  (y = top).

Axiom modus_tollens :
  forall (x:b) (y:b), ((infix_slasbs (infix_mngtas x y) (neg y)) = top) ->
  ((neg x) = top).

Axiom implic :
  forall (x:b) (y:b), ((infix_mngtas x y) = (infix_bsassl (neg x) y)).

Axiom absur :
  forall (x:b) (y:b),
  ((infix_slasbs (infix_mngtas x y) (infix_mngtas x (neg y))) = (neg x)).

Axiom disj_syl :
  forall (x:b) (y:b), ((infix_slasbs (infix_bsassl x y) (neg x)) = top) ->
  (y = top).

Axiom impl_chain :
  forall (x:b) (y:b) (z:b),
  ((infix_slasbs (infix_mngtas x y) (infix_mngtas y z)) = top) ->
  ((infix_mngtas x z) = top).

Axiom impl_comb :
  forall (x:b) (y:b) (z:b) (w:b),
  ((infix_slasbs (infix_mngtas x y) (infix_mngtas z w)) = top) ->
  ((infix_mngtas (infix_slasbs x z) (infix_slasbs y w)) = top).

Axiom currying :
  forall (x:b) (y:b) (z:b),
  ((infix_mngtas (infix_slasbs x y) z) = (infix_mngtas x (infix_mngtas y z))).

Axiom contrapos :
  forall (x:b) (y:b), ((infix_mngtas x y) = (infix_mngtas (neg y) (neg x))).

Axiom binary : forall (x:b), (x = top) \/ (x = bot).

Axiom ifnottop_thenbot : forall (t:b), ~ (t = top) -> (t = bot).

Axiom ifnotbot_thentop : forall (t:b), ~ (t = bot) -> (t = top).

(* Why3 assumption *)
Inductive formula :=
  | Prop1 : b -> formula
  | Var : i -> formula
  | Neg : formula -> formula
  | And : formula -> formula -> formula
  | Or : formula -> formula -> formula
  | Impl : formula -> formula -> formula.
Axiom formula_WhyType : WhyType formula.
Existing Instance formula_WhyType.

(* Why3 assumption *)
Fixpoint eval (e:formula) (v:i -> b) {struct e}: b :=
  match e with
  | Prop1 b1 => b1
  | Var i1 => v i1
  | Neg e1 => neg (eval e1 v)
  | And e1 e2 => infix_slasbs (eval e1 v) (eval e2 v)
  | Or e1 e2 => infix_bsassl (eval e1 v) (eval e2 v)
  | Impl e1 e2 => infix_mngtas (eval e1 v) (eval e2 v)
  end.

(* Why3 assumption *)
Definition infix_eqeq (f1:formula) (f2:formula) : Prop :=
  forall (v:i -> b), ((eval f1 v) = (eval f2 v)).

(* Why3 assumption *)
Inductive atom :=
  | B : b -> atom
  | I : i -> atom
  | Nb : b -> atom
  | Ni : i -> atom.
Axiom atom_WhyType : WhyType atom.
Existing Instance atom_WhyType.

(* Why3 assumption *)
Definition cnf_clause := Init.Datatypes.list atom.

(* Why3 assumption *)
Definition cnf := Init.Datatypes.list (Init.Datatypes.list atom).

(* Why3 assumption *)
Fixpoint eval_cnf_clause (e:Init.Datatypes.list atom)
  (v:i -> b) {struct e}: b :=
  match e with
  | Init.Datatypes.nil => bot
  | Init.Datatypes.cons (B b1) Init.Datatypes.nil => b1
  | Init.Datatypes.cons (I i1) Init.Datatypes.nil => v i1
  | Init.Datatypes.cons (Nb b1) Init.Datatypes.nil => neg b1
  | Init.Datatypes.cons (Ni i1) Init.Datatypes.nil => neg (v i1)
  | Init.Datatypes.cons (B b1) tl => infix_bsassl b1 (eval_cnf_clause tl v)
  | Init.Datatypes.cons (I i1) tl =>
      infix_bsassl (v i1) (eval_cnf_clause tl v)
  | Init.Datatypes.cons (Nb b1) tl =>
      infix_bsassl (neg b1) (eval_cnf_clause tl v)
  | Init.Datatypes.cons (Ni i1) tl =>
      infix_bsassl (neg (v i1)) (eval_cnf_clause tl v)
  end.

(* Why3 assumption *)
Fixpoint eval_cnf (e:Init.Datatypes.list (Init.Datatypes.list atom))
  (v:i -> b) {struct e}: b :=
  match e with
  | Init.Datatypes.nil => top
  | Init.Datatypes.cons hd tl =>
      infix_slasbs (eval_cnf_clause hd v) (eval_cnf tl v)
  end.

(* Why3 assumption *)
Definition equiv_cnf (f1:Init.Datatypes.list (Init.Datatypes.list atom))
    (f2:Init.Datatypes.list (Init.Datatypes.list atom)) : Prop :=
  forall (v:i -> b), ((eval_cnf f1 v) = (eval_cnf f2 v)).

Axiom comm_and1 :
  forall (x:formula) (y:formula), infix_eqeq (And x y) (And y x).

Axiom comm_or1 :
  forall (x:formula) (y:formula), infix_eqeq (Or x y) (Or y x).

Axiom dist_and1 :
  forall (x:formula) (y:formula) (z:formula),
  infix_eqeq (And x (Or y z)) (Or (And x y) (And x z)).

Axiom dist_or1 :
  forall (x:formula) (y:formula) (z:formula),
  infix_eqeq (Or x (And y z)) (And (Or x y) (Or x z)).

Axiom ident_and1 : forall (x:formula), infix_eqeq (And x (Prop1 top)) x.

Axiom ident_or1 : forall (x:formula), infix_eqeq (Or x (Prop1 bot)) x.

Axiom uniq_compl1 :
  forall (x:formula) (y:formula) (z:formula),
  infix_eqeq (Neg x) y /\ infix_eqeq (Neg x) z -> infix_eqeq y z.

Axiom compl_and1 :
  forall (x:formula), infix_eqeq (And x (Neg x)) (Prop1 bot).

Axiom compl_or1 : forall (x:formula), infix_eqeq (Or x (Neg x)) (Prop1 top).

Axiom idem_and1 : forall (x:formula), infix_eqeq (And x x) x.

Axiom idem_or1 : forall (x:formula), infix_eqeq (Or x x) x.

Axiom bound_and1 :
  forall (x:formula), infix_eqeq (And x (Prop1 bot)) (Prop1 bot).

Axiom bound_or1 :
  forall (x:formula), infix_eqeq (Or x (Prop1 top)) (Prop1 top).

Axiom absorp_and1 :
  forall (x:formula) (y:formula), infix_eqeq (And x (Or x y)) x.

Axiom absorp_or1 :
  forall (x:formula) (y:formula), infix_eqeq (Or x (And x y)) x.

Axiom assoc_and1 :
  forall (x:formula) (y:formula) (z:formula),
  infix_eqeq (And x (And y z)) (And (And x y) z).

Axiom assoc_or1 :
  forall (x:formula) (y:formula) (z:formula),
  infix_eqeq (Or x (Or y z)) (Or (Or x y) z).

Axiom demorgan_and1 :
  forall (phi1:formula) (phi2:formula),
  infix_eqeq (Neg (And phi1 phi2)) (Or (Neg phi1) (Neg phi2)).

Axiom demorgan_or1 :
  forall (phi1:formula) (phi2:formula),
  infix_eqeq (Neg (Or phi1 phi2)) (And (Neg phi1) (Neg phi2)).

Axiom negtop1 : infix_eqeq (Neg (Prop1 top)) (Prop1 bot).

Axiom negbot1 : infix_eqeq (Neg (Prop1 bot)) (Prop1 top).

Axiom double_neg1 : forall (x:formula), infix_eqeq (Neg (Neg x)) x.

Axiom dist_ord1 :
  forall (x:b) (y:b) (z:b), infix_lseq x z ->
  ((infix_bsassl x (infix_slasbs y z)) = (infix_slasbs (infix_bsassl x y) z)).

Axiom disj_and1 :
  forall (x:formula) (y:formula), infix_eqeq (And x y) (Prop1 top) ->
  infix_eqeq x (Prop1 top).

Axiom disj_or1 :
  forall (x:formula) (y:formula), infix_eqeq x (Prop1 top) ->
  infix_eqeq (Or x y) (Prop1 top).

Axiom modus_ponens1 :
  forall (x:formula) (y:formula),
  infix_eqeq (And x (Impl x y)) (Prop1 top) -> infix_eqeq y (Prop1 top).

Axiom modus_tollens1 :
  forall (x:formula) (y:formula),
  infix_eqeq (And (Impl x y) (Neg y)) (Prop1 top) ->
  infix_eqeq (Neg x) (Prop1 top).

Axiom implic1 :
  forall (x:formula) (y:formula), infix_eqeq (Impl x y) (Or (Neg x) y).

Axiom absur1 :
  forall (x:formula) (y:formula),
  infix_eqeq (And (Impl x y) (Impl x (Neg y))) (Neg x).

Axiom disj_syl1 :
  forall (x:formula) (y:formula),
  infix_eqeq (And (Or x y) (Neg x)) (Prop1 top) -> infix_eqeq y (Prop1 top).

Axiom impl_chain1 :
  forall (x:formula) (y:formula) (z:formula),
  infix_eqeq (And (Impl x y) (Impl y z)) (Prop1 top) ->
  infix_eqeq (Impl x z) (Prop1 top).

Axiom impl_comb1 :
  forall (x:formula) (y:formula) (z:formula) (w:formula),
  infix_eqeq (And (Impl x y) (Impl z w)) (Prop1 top) ->
  infix_eqeq (Impl (And x z) (And y w)) (Prop1 top).

Axiom currying1 :
  forall (x:formula) (y:formula) (z:formula),
  infix_eqeq (Impl (And x y) z) (Impl x (Impl y z)).

Axiom contrapos1 :
  forall (x:formula) (y:formula),
  infix_eqeq (Impl x y) (Impl (Neg y) (Neg x)).

Axiom pierce :
  forall (x:formula) (y:formula),
  infix_eqeq (Impl (Impl (Impl x y) x) x) (Or x (Neg x)).

(* Why3 assumption *)
Fixpoint size (phi:formula) {struct phi}: Numbers.BinNums.Z :=
  match phi with
  | Neg phi1 => (1%Z + (size phi1))%Z
  | (And phi1 phi2)|((Or phi1 phi2)|(Impl phi1 phi2)) =>
      ((1%Z + (size phi1))%Z + (size phi2))%Z
  | _ => 1%Z
  end.

Axiom size'spec : forall (phi:formula), (0%Z <= (size phi))%Z.

(* Why3 assumption *)
Fixpoint size_cnf_clause
  (phi:Init.Datatypes.list atom) {struct phi}: Numbers.BinNums.Z :=
  match phi with
  | Init.Datatypes.nil => 0%Z
  | Init.Datatypes.cons _ tl => (1%Z + (size_cnf_clause tl))%Z
  end.

Axiom size_cnf_clause'spec :
  forall (phi:Init.Datatypes.list atom), (0%Z <= (size_cnf_clause phi))%Z.

(* Why3 assumption *)
Fixpoint size_cnf
  (phi:Init.Datatypes.list (Init.Datatypes.list atom)) {struct phi}: Numbers.BinNums.Z :=
  match phi with
  | Init.Datatypes.nil => 0%Z
  | Init.Datatypes.cons hd tl => (1%Z + (size_cnf tl))%Z
  end.

Axiom size_cnf'spec :
  forall (phi:Init.Datatypes.list (Init.Datatypes.list atom)),
  (0%Z <= (size_cnf phi))%Z.

(* Why3 assumption *)
Fixpoint is_impl_free (phi:formula) {struct phi}: Prop :=
  match phi with
  | Prop1 _ => True
  | Var _ => True
  | Neg phi1 => is_impl_free phi1
  | (Or phi1 phi2)|(And phi1 phi2) => is_impl_free phi1 /\ is_impl_free phi2
  | Impl _ _ => False
  end.

(* Why3 assumption *)
Fixpoint is_nnfc (phi:formula) {struct phi}: Prop :=
  match phi with
  | Prop1 _ => True
  | Var _ => True
  | Neg (Prop1 _) => True
  | Neg (Var _) => True
  | Neg _ => False
  | (Or phi1 phi2)|(And phi1 phi2) => is_nnfc phi1 /\ is_nnfc phi2
  | Impl _ _ => False
  end.

Axiom nnfc_is_implfree :
  forall (phi:formula), is_nnfc phi -> is_impl_free phi.

(* Why3 assumption *)
Fixpoint is_cnf_clause (phi:formula) {struct phi}: Prop :=
  match phi with
  | Prop1 _ => True
  | Var _ => True
  | Neg (Prop1 _) => True
  | Neg (Var _) => True
  | Neg _ => False
  | Or phi1 phi2 => is_cnf_clause phi1 /\ is_cnf_clause phi2
  | And _ _ => False
  | Impl _ _ => False
  end.

Axiom cnf_clause_is_implfree :
  forall (phi:formula), is_cnf_clause phi -> is_impl_free phi.

Axiom cnf_clause_is_nnfc :
  forall (phi:formula), is_cnf_clause phi -> is_nnfc phi.

(* Why3 assumption *)
Fixpoint is_cnf (phi:formula) {struct phi}: Prop :=
  match phi with
  | Prop1 _ => True
  | Var _ => True
  | Neg (Prop1 _) => True
  | Neg (Var _) => True
  | Neg _ => False
  | Or phi1 phi2 => is_cnf_clause phi1 /\ is_cnf_clause phi2
  | And phi1 phi2 => is_cnf phi1 /\ is_cnf phi2
  | Impl _ _ => False
  end.

Axiom cnf_clause_is_cnf :
  forall (phi:formula), is_cnf_clause phi -> is_cnf phi.

Axiom cnf_is_implfree : forall (phi:formula), is_cnf phi -> is_impl_free phi.

Axiom cnf_is_nnfc : forall (phi:formula), is_cnf phi -> is_nnfc phi.

Axiom cnf_clause1 :
  forall (phi1:formula) (phi2:formula), is_cnf (Or phi1 phi2) ->
  is_cnf_clause phi1 /\ is_cnf_clause phi2.

(* Why3 assumption *)
Fixpoint impl_free (phi:formula) {struct phi}: formula :=
  match phi with
  | Prop1 t => Prop1 t
  | Var i1 => Var i1
  | Neg phi1 => Neg (impl_free phi1)
  | Or phi1 phi2 => Or (impl_free phi1) (impl_free phi2)
  | And phi1 phi2 => And (impl_free phi1) (impl_free phi2)
  | Impl phi1 phi2 => Or (Neg (impl_free phi1)) (impl_free phi2)
  end.

Axiom impl_free'spec :
  forall (phi:formula), forall (v:i -> b),
  ((eval phi v) = (eval (impl_free phi) v)) /\ is_impl_free (impl_free phi).

Parameter nnfc: formula -> formula.

Axiom nnfc'def :
  forall (phi:formula), is_impl_free phi ->
  match phi with
  | Neg (Neg phi1) => ((nnfc phi) = (nnfc phi1))
  | Neg (And phi1 phi2) =>
      ((nnfc phi) = (Or (nnfc (Neg phi1)) (nnfc (Neg phi2))))
  | Neg (Or phi1 phi2) =>
      ((nnfc phi) = (And (nnfc (Neg phi1)) (nnfc (Neg phi2))))
  | And phi1 phi2 => ((nnfc phi) = (And (nnfc phi1) (nnfc phi2)))
  | Or phi1 phi2 => ((nnfc phi) = (Or (nnfc phi1) (nnfc phi2)))
  | _ => ((nnfc phi) = phi)
  end.

Axiom nnfc'spec :
  forall (phi:formula), is_impl_free phi ->
  (forall (v:i -> b), ((eval phi v) = (eval (nnfc phi) v))) /\
  is_impl_free phi /\ is_nnfc (nnfc phi).

Parameter distr: formula -> formula -> formula.

Axiom distr'def :
  forall (phi1:formula) (phi2:formula),
  is_impl_free phi1 /\
  is_impl_free phi2 /\
  is_nnfc phi1 /\ is_nnfc phi2 /\ is_cnf phi1 /\ is_cnf phi2 ->
  match (phi1, phi2) with
  | (And phi11 phi12, phi21) =>
      ((distr phi1 phi2) = (And (distr phi11 phi21) (distr phi12 phi21)))
  | (phi11, And phi21 phi22) =>
      ((distr phi1 phi2) = (And (distr phi11 phi21) (distr phi11 phi22)))
  | (_, _) => ((distr phi1 phi2) = (Or phi1 phi2))
  end.

Axiom distr'spec :
  forall (phi1:formula) (phi2:formula),
  is_impl_free phi1 /\
  is_impl_free phi2 /\
  is_nnfc phi1 /\ is_nnfc phi2 /\ is_cnf phi1 /\ is_cnf phi2 ->
  (forall (v:i -> b),
   ((infix_bsassl (eval phi1 v) (eval phi2 v)) = (eval (distr phi1 phi2) v))) /\
  is_impl_free (distr phi1 phi2) /\
  is_nnfc (distr phi1 phi2) /\ is_cnf (distr phi1 phi2).

Parameter cnfc: formula -> formula.

Axiom cnfc'def :
  forall (phi:formula), is_impl_free phi /\ is_nnfc phi ->
  match phi with
  | Or phi1 phi2 => ((cnfc phi) = (distr (cnfc phi1) (cnfc phi2)))
  | And phi1 phi2 => ((cnfc phi) = (And (cnfc phi1) (cnfc phi2)))
  | _ => ((cnfc phi) = phi)
  end.

Axiom cnfc'spec :
  forall (phi:formula), is_impl_free phi /\ is_nnfc phi ->
  (forall (v:i -> b), ((eval phi v) = (eval (cnfc phi) v))) /\
  is_impl_free phi /\ is_nnfc (cnfc phi) /\ is_cnf (cnfc phi).

(* Why3 assumption *)
Definition t (phi:formula) : formula := cnfc (nnfc (impl_free phi)).

Axiom t'spec :
  forall (phi:formula), forall (v:i -> b),
  ((eval phi v) = (eval (t phi) v)) /\
  is_impl_free (t phi) /\ is_nnfc (t phi) /\ is_cnf (t phi).

Parameter to_cnf_aux: formula -> Init.Datatypes.list atom.

Axiom to_cnf_aux'spec :
  forall (phi:formula),
  is_impl_free phi /\ is_nnfc phi /\ is_cnf_clause phi -> forall (v:i -> b),
  ((eval phi v) = (eval_cnf_clause (to_cnf_aux phi) v)).

Parameter phi: formula.

Axiom H : is_impl_free phi.

Axiom H1 : is_nnfc phi.

Axiom H2 : is_cnf phi.

Parameter result: Init.Datatypes.list (Init.Datatypes.list atom).

Parameter result1: Init.Datatypes.list (Init.Datatypes.list atom).

Parameter result2: Init.Datatypes.list (Init.Datatypes.list atom).

Parameter x: formula.

Parameter x1: formula.

Axiom H3 : (phi = (And x x1)).

Axiom Ensures : forall (v:i -> b), ((eval x1 v) = (eval_cnf result1 v)).

Axiom Ensures1 : forall (v:i -> b), ((eval x v) = (eval_cnf result2 v)).

Axiom H4 : (result = (Init.Datatypes.app result2 result1)).

Parameter v: i -> b.

(* Why3 goal *)
Theorem to_cnf'vc : ((eval phi v) = (eval_cnf result v)).

auto.
